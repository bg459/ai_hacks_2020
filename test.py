# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dzHgffINos1yf0Giolg74jYhmQ9Z29PR
"""

import time
from datetime import datetime
from dateutil.tz import tzutc
from ast import literal_eval

import re
import numpy as np
import pandas as pd

from sklearn.naive_bayes import MultinomialNB
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.preprocessing import LabelEncoder

import joblib
import pickle
from sklearn import preprocessing
import sys
import warnings
warnings.filterwarnings("ignore")

# add test cases here
#patient = 26207
patient = int(sys.argv[1])
patient_info = pd.read_csv('patients_test.csv')
videos = pd.read_csv('videos_test.csv').set_index('Unnamed: 0')
videos.head()

patient_info = patient_info[['patient_id', 'age', 'sex', 'has_bh_specialist', 'total_activities_done', 'unique_days_with_activity']]
patient_info = pd.get_dummies(patient_info, columns = ['sex', 'has_bh_specialist'])

big = patient_info.merge(videos, on = "patient_id")

video_stats = big.groupby(['video_id']).mean()
video_features = videos.groupby('video_id').mean()
video_features['avg_age'] = video_stats['age']
video_features['gender'] = video_stats['sex_Male']

# Normalize, PCA
cols = list(video_features.columns)
x = video_features.values #returns a numpy array
min_max_scaler = preprocessing.MinMaxScaler()
min_max_scaler.fit(x)
x_scaled = min_max_scaler.transform(x)
video_features = pd.DataFrame(x_scaled)
dims = len(video_features.columns)

from sklearn.decomposition import PCA
pca = joblib.load('pca2.pkl')
reduced_movie_features = pca.transform(video_features)
reduced_movie_features = pd.DataFrame(reduced_movie_features)
reduced_movie_features = reduced_movie_features.set_index(video_stats.index.values)

patient_features = big.groupby(['patient_id']).mean()
patient_features = patient_features [['age', 'sex_Female', 'sex_Male', 'has_bh_specialist_False', 'has_bh_specialist_True',
                                      'length', 'video_created_time', 'video_views', 'primary_category_ADHD',
                                      'primary_category_Anxiety', 'primary_category_Cognitive Behavioral Therapy',
                                      'primary_category_Depression', 'primary_category_Managing Pain',
                                      'primary_category_Mindfulness', 'primary_category_New & Expecting Mothers',
                                      'primary_category_PTSD', 'primary_category_Sleep', 'primary_category_Stress',
                                      'primary_category_Substance Use', 'primary_category_Yoga']]
patient_features = patient_features.dropna()
patient_index = patient_features.index.values
patient_features_unscaled = patient_features.copy()
cols = list(patient_features.columns)
x = patient_features.values #returns a numpy array
min_max_scaler = preprocessing.MinMaxScaler()
x_scaled = min_max_scaler.fit_transform(x)
patient_features = pd.DataFrame(x_scaled)

user_pca = joblib.load('pca4.pkl')
reduced_patient_features = user_pca.transform(patient_features)
reduced_patient_features = pd.DataFrame(reduced_patient_features)
reduced_patient_features = reduced_patient_features.set_index(patient_index)
patient_features = patient_features.set_index(patient_index)

from scipy import spatial
vids = video_stats.index.values

def get_closest_user(user, k, pca):
  """For a given user, returns the k nearest neighbors in the new PCA feature space.
  params:
  user - id of the user in question (int)
  k - number of nearest neighbors
  pca - PCA object for transform."""
  patient_pca = pca.transform(patient_features)
  patients = patient_features.index.values
  patient_pca = pd.DataFrame(patient_pca)
  patient_pca = patient_pca.set_index(patients)

  patient_index = patient_pca[patient_pca.index.values == user]

  patient_similarity = [spatial.distance.cosine(list(patient_index), list(x)[1:]) for x in patient_pca.itertuples()]

  closest_indices = np.argpartition(patient_similarity, k+1).tolist()[1:k+1]
  return patients[closest_indices]

def get_closest_movie(movie, user, k, pca):
  """For a given movie, return the k nearest movies in the new PCA feature space.
  This movie cannot be seen before by the user. (Business logic)
  params:
  movie = vector of average movie
  user = user id 
  k = number of nearest neighbors
  pca = pca object"""

  
  video_pca = pca.transform(video_features)
  patients = video_features.index.values
  video_pca = pd.DataFrame(video_pca)
  video_pca = video_pca.set_index(vids)

  
  transformed_movie = pca.transform(movie.reshape(-1, 1))[0]

  video_similarity = [spatial.distance.cosine(transformed_movie, list(x)[1:]) for x in video_pca.itertuples()]

  closest_indices = np.argpartition(video_similarity, k+1).tolist()[1:k+1]

  video_similarity = np.array(video_similarity)
  return vids[closest_indices], video_similarity[closest_indices]
  
def predict_next_movie(user_id, user_pca, pca):
  """
  Predicts a user's next movie. Takes in user ID, the pca of user space, and the
  PCA object of video space. First finds the nearest neighbors to this user, then
  finds the top 10 videos of these nearest neighbors.
  """

  closest_patients = get_closest_user(user_id, 10, user_pca)
  # Takes all the features of the closest users
  closest_features = patient_features[patient_features.index.isin(closest_patients)]
  # Getting rid of the non-video related features
  closest_mov = np.array((closest_features.iloc[:, 5:].mean()))
  # Finds the closest 10 videos
  recommendations, similarities = get_closest_movie(closest_mov, user_id, 10, pca)
  
  return recommendations, similarities

recommendations, similarities = predict_next_movie(patient, user_pca, pca)
vids_orig = pd.read_csv('video_watched_events_CONFIDENTIAL.csv')
print('Based on your previous watch history, we recommend:')
print()
for rec in recommendations:
  print(vids_orig.loc[rec, :].notes + ': ' + vids_orig.loc[rec, :].url)
